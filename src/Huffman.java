
import java.util.*;

import java.io.*;

public class Huffman {

    String fileInput;
    String fileOutput;
    String parameters;
    BitInputStream bitInputStream;
    BitOutputStream bitOutputStream;
    HashMap<Byte, Integer> tableFrequences = new HashMap<>();
    HashMap<Byte, String> tableCodes = new HashMap<>();
    Queue<Byte> file = new LinkedList<>();

    public Huffman(String fileInput, String fileOutput) {
        this.fileInput = fileInput;
        this.fileOutput = fileOutput;
        this.bitInputStream = new BitInputStream(fileInput);
    }

    public void compress() throws IOException {

        try (FileInputStream fileinputStream = new FileInputStream(fileInput)) {
            byte currentByte;
            int b = fileinputStream.read();
            while (b > -1) {
                currentByte = (byte) b;
                addToFrequencyTable(currentByte);
                file.add(currentByte);

                b = fileinputStream.read();
            }
        }
        // trie la liste par fréquences on utilise lambda pour comparer les fréquences
        PriorityQueue<HuffmanNode> huffmanQueue = new PriorityQueue<>(tableFrequences.size(),
                (HuffmanNode o1, HuffmanNode o2) -> o1.frequence - o2.frequence);

        // ajouter les données du hashMap dans la queue
        for (Map.Entry<Byte, Integer> entry : tableFrequences.entrySet())
            huffmanQueue.add(new HuffmanNode(entry.getKey(), entry.getValue(), false));

        HuffmanNode racine = null;

        while (huffmanQueue.size() > 1) {

            // on retrieve les 2 min de la queue
            HuffmanNode h1 = huffmanQueue.poll();
            HuffmanNode h2 = huffmanQueue.poll();

            // crée un nouveau qui a la somme de frequence
            HuffmanNode hsum = new HuffmanNode(h1.frequence + h2.frequence, true);

            hsum.left = h1;
            hsum.right = h2;
            racine = hsum;

            // on rajoute le noeud combiné dans la queue
            huffmanQueue.add(hsum);
        }

        // prend le dernier élément (racine) de la Queue
        racine = huffmanQueue.poll();

        // on commence par encoder le treemap dans le fichier
        BitOutputStream bos = new BitOutputStream(fileOutput);

        // le premier byte sera la taille de bits que prend le Huffman Tree dans le
        // fichier
        int tailleTree = 10 * tableFrequences.size() - 1;
        String result = String.format("%8s", Integer.toBinaryString(tailleTree)).replace(" ", "0");

        // on écrit le byte bit par bit dans le Stream
        for (int n = 0; n < result.length(); n++)
            bos.writeBit(Character.getNumericValue(result.charAt(n)));

        encodeHuffmanTreemap(racine, bos);

        System.out.println("number bit : " + test);
        // ferme le stream à la fin de l'écriture

        createCode(racine, "");

        // écrire le code compressé dans le file
        Byte b = file.poll();
        while (b != null) {
            String code = tableCodes.get(b);
            // on écrit le byte bit par bit dans le Stream
            for (int n = 0; n < code.length(); n++)
                bos.writeBit(Character.getNumericValue(code.charAt(n)));
            b = file.poll();
        }

        bos.close();

    }

    int test = 0;

    /**
     * méthode qui sert à encoder le Huffman treeMap au début du fichier.
     * https://stackoverflow.com/questions/759707/efficient-way-of-storing-huffman-tree
     * 
     * https://mkyong.com/java/java-how-to-convert-a-byte-to-a-binary-string/
     * 
     * @param bos
     * @param racine
     */
    public void encodeHuffmanTreemap(HuffmanNode racine, BitOutputStream bos) {

        if (!racine.isCombined) {
            bos.writeBit(1);
            int result = racine.symbole & 0xff;
            String resultWithPadZero = String.format("%8s", Integer.toBinaryString(result)).replace(" ", "0");

            // on écrit le byte bit par bit dans le Stream
            for (int n = 0; n < resultWithPadZero.length(); n++)
                bos.writeBit(Character.getNumericValue(resultWithPadZero.charAt(n)));

        } else {
            bos.writeBit(0);

            encodeHuffmanTreemap(racine.left, bos);
            encodeHuffmanTreemap(racine.right, bos);
        }
    }

    /**
     * La méthode createCode va permettre de créer la table de codes par symboles
     * pour la compression
     * 
     * @param noeud
     * @param s
     */
    public void createCode(HuffmanNode noeud, String s) {

        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (noeud.left == null && noeud.right == null && !noeud.isCombined) {
            // on l'ajoute à la table de codes
            tableCodes.put(noeud.symbole, s);
            System.out.println("symbole : " + noeud.symbole + " freq : " + noeud.frequence + " code :" + s);
            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.

        // recursive calls for left and
        // right sub-tree of the generated tree.
        createCode(noeud.left, s + "0");
        createCode(noeud.right, s + "1");
    }

    // calcul le nombre de fois le byte est repeté
    public void addToFrequencyTable(Byte b) {

        if (!tableFrequences.containsKey(b)) {
            tableFrequences.put(b, 1);
        } else {
            tableFrequences.put(b, tableFrequences.get(b) + 1);
        }
    }






    public void decode_files (HuffmanNode racine, String s) {

        if(racine == null) return;
        StringBuilder stringBuilder = new StringBuilder();

        int position = 0;
        Node current = racine;

        Char[] aChar = s.toCharArray();

        while(){

        }


    }


}
