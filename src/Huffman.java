
import java.util.*;

import java.io.*;

public class Huffman {

    String fileInput;
    String fileOutput;
    String parameters;
    List<Integer> compressedFile;
    BitInputStream bitInputStream;
    BitOutputStream bitOutputStream;
    HashMap<Byte, Integer> frequency = new HashMap<Byte, Integer>();
    Stack stack;

    public Huffman() {

    };

    public Huffman(String fileInput, String fileOutput) {
        this.fileInput = fileInput;
        this.fileOutput = fileOutput;
        this.bitInputStream = new BitInputStream(fileInput);
        compressedFile = new ArrayList<>();
    }

    public Huffman(String fileInput, String fileOutput, String parameters) {
        this.fileInput = fileInput;
        this.fileOutput = fileOutput;
        this.parameters = parameters;
        this.bitInputStream = new BitInputStream(fileInput);
        compressedFile = new ArrayList<>();
    }

    public void compress() throws IOException {

        try (FileInputStream fileinputStream = new FileInputStream(fileInput)) {
            byte currentByte;
            int b = fileinputStream.read();
            while (b > -1) {
                currentByte = (byte) b;
                addToFrequencyTable(currentByte);
                b = fileinputStream.read();
            }
        }
        // trie la liste par fréquences on utilise lambda pour comparer les fréquences
        PriorityQueue<HuffmanNode> huffmanQueue = new PriorityQueue<>(frequency.size(),
                (HuffmanNode o1, HuffmanNode o2) -> o1.frequence - o2.frequence);

        // ajouter les données du hashMap dans la queue
        for (Map.Entry<Byte, Integer> entry : frequency.entrySet())
            huffmanQueue.add(new HuffmanNode(entry.getKey(), entry.getValue(), false));

        HuffmanNode racine = null;

        while (huffmanQueue.size() > 1) {

            // on retrieve les 2 min
            HuffmanNode h1 = huffmanQueue.poll();
            HuffmanNode h2 = huffmanQueue.poll();
            // crée un nouveau qui a la somme de frequence
            HuffmanNode hsum = new HuffmanNode(h1.frequence + h2.frequence, true);

            hsum.left = h1;
            hsum.right = h2;
            racine = hsum;

            // on rajoute le noeud combiné dans la queue
            huffmanQueue.add(hsum);
        }

        // prend le dernier élément (racine) de la Queue
        racine = huffmanQueue.poll();

        // on commence par encoder le treemap dans le fichier
        BitOutputStream bos = new BitOutputStream(fileOutput);

        encoderHuffmanTreemap(racine, bos);

        // ferme le stream à la fin de l'écriture
        bos.close();
        printCode(racine, "");

    }

    /**
     * méthode qui sert à encoder le Huffman treeMap au début du fichier.
     * https://stackoverflow.com/questions/759707/efficient-way-of-storing-huffman-tree
     * 
     * @param bos
     * @param racine
     */
    public void encoderHuffmanTreemap(HuffmanNode racine, BitOutputStream bos) {
        // f
    }

    public void printCode(HuffmanNode noeud, String s) {

        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (noeud.left == null && noeud.right == null && !noeud.isCombined) {

            // c is the character in the node
            System.out.println(noeud.symbole + "    " + noeud.frequence + ":" + s);

            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.

        // recursive calls for left and
        // right sub-tree of the generated tree.
        printCode(noeud.left, s + "0");
        printCode(noeud.right, s + "1");
    }

    public void encode(Stack stack, String code, Map<Character, String> huffman) {
        if (stack == null)
            return;
        if (stack.left == null && stack.right == null) {
            huffman.put(stack.aChar, code);
        }
        encode(stack.left, code + '0', huffman);
        encode(stack.right, code + '1', huffman);
    }

    public int decode(Stack stack, int pos, StringBuilder stringBuilder) {
        if (stack == null)
            return pos;
        if (stack.left == null && stack.right == null) {
            return pos;
        }
        pos++;

        if (stringBuilder.charAt(pos) == '0')
            pos = decode(stack.left, pos, stringBuilder);
        else
            pos = decode(stack.right, pos, stringBuilder);
        return pos;
    }

    // calcul le nombre de fois le byte est repeté
    public void addToFrequencyTable(Byte b) {

        if (!frequency.containsKey(b)) {
            frequency.put(b, 1);
        } else {
            frequency.put(b, frequency.get(b) + 1);
        }
    }

    public Stack addRecursive(Stack current, int value) {
        if (current == null) {
            return new Stack(value);
        }

        if (value < current.aPos) {
            current.left = addRecursive(current.left, value);
        } else if (value > current.aPos) {
            current.right = addRecursive(current.right, value);
        } else {
            // value already exists
            return current;
        }

        return current;
    }

    public void add(int value) {
        stack = addRecursive(stack, value);
    }

}
